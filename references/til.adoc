
## About

TIL standards for "Today I Learnt". The idea is by recording small things learnt their learning will be better retained. In the large I think it also provides a nice rough way of tracking progress every once in a while, and finding patterns in one's self that would otherwise be missed. This idea is not mine, but rather what I've seen others do e.g. https://github.com/jbranchaud/til/commits/master[here] https://github.com/thoughtbot/til[here] and https://github.com/milooy/TIL[here]. I think its a nifty idea worth emulating.

Items below are ordered latest to oldest. Look at the git history for the actual dates.

## TIL

* found out that asciidoc does not support strikethough in a way that supports Github (or viceversa) https://github.com/asciidoctor/asciidoctor/issues/1030[link] https://github.com/christiangalsterer/bitbucket-asciidoc-plugin/issues/15[link]. This prevented me from being able to format a log title in the way I wanted.

* Amazon Alexa is a kind of voice-based interface not unlike Apple Siri.
** Amazon Echo is a hardware product line that makes Alexa convenient to use
** Developers can "teach Alexa skills" which is analogus to e.g. writing iOS apps. teach -> write, skill -> app
** Alexa skills are configured with an amazon developer account, then implemented. The skill's interaction model is defined in this configuration layer, e.g. what utterances can be used.
** `Invocation Name` is the name given to enter your skill from alexa. For example `essence` will enter the `ssense` skill
** Each skill has multiple `intents`. These are like functions or endpoints in your skill. You defined them as a developer.
** Each intent has multiple `utterances`. These are ways the user can speak to execute the intent.
** There is another concept called `slots` which are for parameters in intents. But I have not actually played with these yet.
** There are different APIs available for developers to use to build skills. For highly custom skills there is a Custom API which can POST intents to any host running an HTTPS server.
** links: https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/getting-started-guide[Alexa Skills entry point for developers], https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/build-skills-for-echo-show#display-and-interaction-features-on-echo-show[Amazon Echo Show entry point for developers], https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/overviews/understanding-custom-skills[Custom API], https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/alexa-skills-kit-interface-reference[JSON Interface Reference for Custom Skills], https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/display-interface-reference[Display Interface Reference]

* DGraph's https://godoc.org/github.com/dgraph-io/dgraph/client[go client] is their most feature complete one. DGraph's https://github.com/dgraph-io/dgraph/tree/master/cmd/dgraphloader[`dgraphloader`] is built on top of it.


'''

* learnt about the following `dgraph` `mutation` today.
+
```
mutation {
  set {
   _:cat <name> "Millhouse" .
   _:cat <color> "Black" .
   _:cat <age> "0.7"^^<xs:float> .

   _:human <name> "Kaley" .
   _:human <age> "22"^^<xs:float> .
   _:human <favorite_food> "chocolate" .

   _:human <owns> _:cat .
  }

  schema {
   name: string @index .
  }
}
```
** `mutation` is for changing data in the graph or changing the graph schema
** `set` is for mutations that insert triples into the graph
** the strange syntax `^^<xs:float>` is apparently how a value is typed as a float...

* about `dgraph` triples
** triples are specified according the W3C standard https://www.w3.org/TR/n-quads/[RDF N-Quad format]
** their format is `<subject> <predicate> <object> .` `subject` is always a node. `object` is either a `node` or a `value` (also know as literal). `predicate` is a directed edge from `subject` to `object`, the value here is the edge name. A given edge must always point to a consistent type (in effect the edge type). A `.` is present because of the spec apparently less because of need on dgraph side https://dgraph.slack.com/archives/C13LH03RR/p1504754827000129[link]

* `blank node` is written `_:identifier` in a mutation. Used to identify a node within a mutation. Outside a particular mutation the identifiers have no existance. `_` will be replaced by dgraph with an automatically generated 64bit unique ID. These IDs are available in the mutation return result:
+
```
{
  "data": {
    "code": "Success",
    "message": "Done",
    "uids": {
      "foo": "0x2712",
      "qux": "0x2713",
      "bar": "0x2714"
    }
  }
}
```

* links: https://docs.dgraph.io/query-language/#mutations[mutation docs], https://docs.dgraph.io/master/guides/#adding-data-to-dgraph[guide/intro to mutations]

* in `dgraph` schema types are defined globally without any ability to nest into records. https://dgraph.slack.com/archives/C13LH03RR/p1504755357000113[link]. For example this would fail:
+
```
mutation {
  schema {
    foo {
      bar: string .
    }
  }
}
```
+
but this would work:
+
```
mutation {
  schema {
    bar: string .
  }
}
```




* `dgraph` supports pagination which can be used as the basis for doing batch work across an entire graph. https://dgraph.slack.com/archives/C13LH03RR/p1504745800000004[slack link], https://docs.dgraph.io/master/query-language/#pagination[pagination docs link]

'''

* https://dgraph.io[dgraph] has enough power in its query language to apply both collaborative-based and content-based filtering strategies https://blog.dgraph.io/post/recommendation[link] https://blog.dgraph.io/post/recommendation2/[link].

* _collaborative-based filtering_ is a broad strategy for recommending things based upon matching like-users and then recommending to one based on another(s).

* _cold-start_ problem refers to being unable to integrate a new user into collaborative-based filtering for lack of data with that user.

* _content-based filtering_ is a broad strategy for recommending things based on their similarity to another given thing.
