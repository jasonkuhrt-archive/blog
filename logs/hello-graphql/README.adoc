:toc: macro
:toc-title:
:sectanchors:
:toclevels: 99

# Hello GraphQL

toc::[]

2017 November 8

## Hello World

GraphQL is a technology that enables clients to fetch just the data they need from backends in a predictable and safe way. Predictable because the query shape is the data shape, safe because queries operate on strongly typed data. At its core GraphQL is just a http://facebook.github.io/graphql[specification]. The surrounding community extends it, builds tools around it, and helps evolve it. It was originally developed at Facebook in 2012 but later open-sourced in 2015. Over the following two years many companies adopted it for internal APIs (https://open.nytimes.com/react-relay-and-graphql-under-the-hood-of-the-times-website-redesign-22fb62ea9764[New York Times], https://www.youtube.com/watch?v=T3FbZsYXi50[IBM], https://dev-blog.apollodata.com/courseras-journey-to-graphql-a5ad3b77f39a[Coursera], ...), but some companies also launched public APIs (https://www.youtube.com/watch?v=Baw05hrOUNM[Twitter], https://developer.github.com/v4/[Github], https://www.yelp.com/developers/graphql/guides/intro[Yelp], ...).

Here is an example of a GraphQL query:

```graphql
query Product(id: "ab781du3", language: EN) {
  name,
  description,
  sizes: {
    name,
    stock,
  }
}
```

## A mental model

### Queries

. client makes a request
. request gets syntactically validated
. request gets validated against schema
. requested fields get resolved into data
. response is sent back

### Mutations

. client makes a request
. request gets syntactically validated
. request gets validated against schema
. mutation is carried out
. requested response fields are resolved into data
. response is sent back

### Subscriptions

. client makes a request
. request gets syntactically validated
. request gets validated against schema
. new subscriber for event source is registered
. each event from source is executed against with originally given query
. ...then the resolved data is sent back

## A Specification

GraphQL is a specification that chiefly defines a type system and a query language.

### Not everything is specified

Many aspects of GraphQL that will need to be solved in production are intentionally left unspecified. Some notable omissions include what transport to use (HTTP is not mentioned anywhere for example), how authorization should work, how error handling should work. This is a tradeoff. A key advantage is that the community can explore unspecified spaces to discover new solutions that offer optimal tradeoffs. But now efforts will be fragmented leading to a host of negatives like more decisions to make in userland and less mature libraries, tooling, etc. But arguably the wrong standard is worse than no standard and so for example it seems reasonable that if authorization architecture looks very different from one company to the next it should not be standardized. And certainly one may hope that if over time if a clearly superior design pattern emerges from the community it will be folded back into the core spec somehow, or failing that perhaps instead specified as an extension like Facebook's https://facebook.github.io/relay/graphql/connections.htm[Relay Cursor Connections Specification].

## Anatomy of GraphQL Schema

This section will introduce GraphQL's type system.

References:

- https://github.com/sogko/graphql-schema-language-cheat-sheet[cheatsheet]

### Scalers

GraphQL has a base set of types that all other types are just compounds of. These base types are referred to as https://stackoverflow.com/questions/6623130/scalar-vs-primitive-data-type-are-they-the-same-thing[scalers] and are:

* Int - signed 32-bit integer
* String - UTF-8 character sequence
* Float - signed double-precision floating-point value
* Boolean - true or false
* ID - a string for uniquely identifying something in a non-human-readable way

A GraphQL implementation may also extend this set of scalers with new ones e.g. Email, Date, PhoneNumber, URL, etc.

Example:

```
type Product {
  id: ID
  name: String
  price: Float
  stock: Int
  tood: Boolean
}
```

### Enumeration

Enumeration types allow expressing that a field will be one of several different values. It is a better choice than a string when the possible values are within a controlled set. A good candidate for enumerations can be strings that you see in code being tested for concrete matches like `gender == "men"` and `size == "xs"`. An enumeration in GraphQL is like a scaler type in that it is a leaf of your query.

```
Size = {
  S
  M
  L
}
```
```
enum Gender = {
  MALE
  FEMALE
}
```
```
enum Order_Status = {
  INVOICED
  PICKED
  PACKED
  SHIPPED
  DELIVERED
  RETURNED
}
```

### Union

Union types allow expressing that a field may be one of several different Object types.

Example:
```
type Product {
  id: ID
  name: String
  price: Float
}

type Article {
  id: ID,
  title: String
  author: String
}

union SearchResult = Product | Article
```

You may be wondering how one queries on such a type:

```
search(term:String) {
  searchResult: {
    # ... fields for Product or Article ...???
  }
}
```

We will answer this once we dive into queries.

You may also be wondering how this relates to Sum Types (AKA Tagged Union Types, variant Record, Discriminated Union, Disjoint Union). My take is that while GraphQL Union types have some similarities to Sum Types they are less flexible given that they are constrained to being a union of just Object types. By comparison, Sum Types in the type systems of Haskell Rust Swift and many other programming languages are effectively a superset of enums:

1. Analog to GraphQL `Enumeration`:
+
```haskell
type Size = S | M | L
```
+
```haskell
type Gender = Male | Female
```

2. Analog to GraphQL `Union`:
+
```haskell
type SearchResult = Product String String Float | Article String String String
```

Alas in GraphQL we must cope with less general/flexible types, but thankfully taken together can still model our data with expressivity at least approaching Sum Types. I haven't yet taken the time to confirm with the community if this is true but I suspect that GraphQL's design decisions here were related to other design considerations on the query side, when actually fetching data against these types. As we will see queries against enum types versus union types are quite different.

If you do not have extensive experience modelling your data with Sum or Sum-like types you may find this article by Chad Austin useful: https://chadaustin.me/2015/07/sum-types/[Sum Types Are Coming: What You Should Know].

### Interface

Interface types allow expressing a set of fields that other Object types must have.

```
interface Product {
  id: ID
  name: String
  price: Float
  countryOfManufacture: Country
  brand: Brand
  colour: Colour
  gender: Gender
}

type Bag implements Product {
}

type Shoe implements Product {
}

```

This has multiple benefits. For schema authors working at scale Interfaces are a design tool helping them reason about data relationships and enforcing those relationships at the server level. For clients, interfaces allow queries on unions to be simplified in some cases.

### Object

Object types are the workhorse of the schema, providing the means to create a set of named and typed fields that are modelling some domain.

```
type Product = {
  id: ID
  name: String
  price: Float
  countryOfManufacture: Country
  brand: Brand
  colour: Colour
  gender: Gender
}
```

### List a

List types allow expressing many of something.

```
type SearchResult = {
  products: [Product]
}
```

### Non-Null

Maybe types are the default in GraphQL but may be opted out by specifying the field as not nullable.
we can improve our previous `SearchResult` type from before by telling the client that search results will never be null and that results found will never be null.

```
type SearchResult = {
  products: [Product!]!
}
```

This makes life for the client easier because we have just removed two edge-cases that they previously had to worry about.

While non-null simplifies what a client has to account for care should be taken by schema authors to not over-promise during design. Firstly, changing a field type from not-nullable to nullable is a breaking change while the reverse is not. Secondly, null propagates up the tree of fields to the first nullable field and so if null occurs when it was guaranteed not to the damage done on the result will likely be worse than had null been a field possibility. For example instead of a single item in a list having an image link field be null the entire result of items might become null instead.

Both of these points are discussed in greater detail by Caleb Meredith in https://medium.com/@calebmer/when-to-use-graphql-non-null-fields-4059337f6fc8[When to use GraphQL Non-Null Fields].

### Input Object

## Anatomy of GraphQL Queries

Hopefully you now have a sense of what GraphQL is. Lets survey some of its main features so that you have a deeper understanding of what it can and cannot do in more precise operational terms.

### Document
### Selection Set
### Operation (query, mutation, subscription)
### Aliases
### Functions
### Opt-in
### Directives
### Fragments
### Variables

## Case Study

TODO

### Making a query

```
fragment RelatedProduct on Product {
  id,
  name,
  price: {
    amount(formatted: true)
  },
  primary_image(height: 50): {
    width,
    height,
    alt_text
  }
}
```
```
fragment AllMeasurements on ProductMeasurements {
  ... on Shirt {
    shoulders,
    chest,
    length,
    sleeve,
  }
}
```
```
query product(id: $product_id, language: $language, region: $region) {
  sku,
  name,
  summary,
  description,
  material_facts,
  in_my_wishlist,
  model: {
    description,
    size: {
      chest,
      hip,
      shoulder,
      waist,
    }
  },
  price {
    amount
    amount_formatted: amount(formatted: true),
    currency_name
  },
  styled_with: {
    ...RelatedProduct
  },
  images(width: 400): {
    width,
    height,
    alt_text
  },
  sizes: {
    id,
    name
    measurements: {
      ...AllMeasurements
    },
    stock,
  },
  category: {
    product_sizing_diagram,
    id,
    name
    products (limit: 7): {
      ...RelatedProduct
    }
  },
  brand: {
    id,
    name
    products(limit: 5, like_product: $product_id): {
      ...RelatedProduct
    }
  }
}
```

## Ecosystem

* queries are typed out literally in code, as-you-type validation
* GraphiQL, Voyager, Graphcool, Graphene, Relay, Apollo Client, Apollo Engine
* Authorization goes into the Authorization header
* user context aka `viewer` pattern
* Localization goes into Accept-Language header
* backend teams know how their servers are being used
* frontend teams only pay for what they use, example at SSENSE with price field

### Schema Driven Development

Interestingly schema definitions like the examples we saw while introducing the type system or presenting the case study can be transformed into a functioning GraphQL server by https://github.com/apollographql/graphql-tools[Apollo GraphQL Tools]. This is a declarative way of creating a GraphQL service because you simply say what the interface is and it becomes so. Apollo has termed this approach https://www.apollographql.com/docs/graphql-tools/index.html#recommendations[the GraphQL-first philosophy].


## Novelty

* Some of the things that make GraphQL notable are:

** its conservative iterative and organic development over years of production experience
** originated as a data solution for mobile apps, still driven by needs of frontend engineers
** particularly strong ecosystem support for React
** its rich type system including union types and opt-in null-free
** its opt-in field-level granularity query model
** its fields-are-functions query model
** its ecosystem of tooling
** its fundamental flexibility, such as not even requiring HTTP
** its interface unification of streaming and request-response

Some other technologies have overlapping benefits like https://grpc.io[gRPC]  (strong types, unified streaming/request-response interface) or http://netflix.github.io/falcor/[Falcor] (graph queries, data layer abstraction), but GraphQL is ultimately highly unique in its intersection of characteristics.

## An Ecosystem

TODO

## Summary

* GraphQL is a **specification** with _many implementations_
* GraphQL was originally created at Facebook but is now developed in the open by many companies and engineers.
* https://www.apollodata.com/[Apollo] is the/one of the most directly involved/invested companies in furthering the technology (not consumer but driver) outside of Facebook. Apollo is part of https://www.meteor.com[Meteor].

## References

* http://graphql.org/learn[official docs]
* http://facebook.github.io/graphql[spec]
* https://www.howtographql.com/
* https://github.com/chentsulin/awesome-graphql[awesome-graphql]
* https://twitter.com/tomdale/status/786951612053020672?lang=en
