:toc: macro
:toc-title:
:sectanchors:
:toclevels: 99

# Hello GraphQL

toc::[]

2017 November 8

## Hello World

GraphQL is a technology that enables clients to fetch just the data they need from backends in a predictable and safe way. Predictable because the query shape is the data shape, safe because queries operate on strongly typed data. At its core GraphQL is just a http://facebook.github.io/graphql[specification]. The surrounding community extends it, builds tools around it, and helps evolve it. It was originally developed at Facebook in 2012 but later open-sourced in 2015. Over the following two years many companies adopted it for internal APIs (https://open.nytimes.com/react-relay-and-graphql-under-the-hood-of-the-times-website-redesign-22fb62ea9764[New York Times], https://www.youtube.com/watch?v=T3FbZsYXi50[IBM], https://dev-blog.apollodata.com/courseras-journey-to-graphql-a5ad3b77f39a[Coursera], ...), but some companies also launched public APIs (https://www.youtube.com/watch?v=Baw05hrOUNM[Twitter], https://developer.github.com/v4/[Github], https://www.yelp.com/developers/graphql/guides/intro[Yelp], ...).

Here is an example of a GraphQL query:

```graphql
query Product(id: "ab781du3", language: EN) {
  name,
  description,
  sizes: {
    name,
    stock,
  }
}
```

## A mental model

### Queries

. client makes a request
. request gets syntactically validated
. request gets validated against schema
. requested fields get resolved into data
. response is sent back

### Mutations

. client makes a request
. request gets syntactically validated
. request gets validated against schema
. mutation is carried out
. requested response fields are resolved into data
. response is sent back

## A Specification

GraphQL is a specification that chiefly defines a type system and a query language.

### Not everything is specified

Many aspects of GraphQL that will need to be solved in production are intentionally left unspecified. Some notable omissions include what transport to use (HTTP is not mentioned anywhere for example), how authorization should work, how error handling should work. This is a tradeoff. A key advantage is that the community can explore unspecified spaces to discover new solutions that offer optimal tradeoffs. But now efforts will be fragmented leading to a host of negatives like more decisions to make in userland and less mature libraries, tooling, etc. But arguably the wrong standard is worse than no standard and so for example it seems reasonable that if authorization architecture looks very different from one company to the next it should not be standardized. And certainly one may hope that if over time if a clearly superior design pattern emerges from the community it will be folded back into the core spec somehow, or failing that perhaps instead specified as an extension like Facebook's https://facebook.github.io/relay/graphql/connections.htm[Relay Cursor Connections Specification].

## Basic Types and Queries

We will start by looking at basic types and simple queries in GraphQL. These types are used by backend engineers to model a domain of underlying data that they are interested in exposing to clients. We refer to this overall application of types as the schema.

### Scalers

GraphQL has a base set of types that all other types are just compounds of. These base types are referred to as https://stackoverflow.com/questions/6623130/scalar-vs-primitive-data-type-are-they-the-same-thing[scalers] and are:

* `Int` - signed 32-bit integer
* `String` - UTF-8 character sequence
* `Float` - signed double-precision floating-point value
* `Boolean` - true or false
* `ID` - a string for uniquely identifying something in a non-human-readable way

A GraphQL implementation may also extend this set of scalers with new ones e.g. Email, Date, PhoneNumber, URL, etc.

Conceptually scaler types are leaf nodes in the server's graph of data. They represent an atomic unit of data, a datum, that hence cannot be drilled down upon any further.

Here is an example, but note the surrounding part `type Product { ... }` is a compound type called an Object type. It is not possible in GraphQL to have top-level leaf nodes. We will cover Object types shortly.

```
type Product {
  id: ID
  name: String
  price: Float
  stock: Int
  fairTrade: Boolean
}
```

### Enumeration

Enumeration types allow expressing that a field will be one of several different values. It may be a better choice than a string when the possible values are within a controlled set. For example if you see strings that are being tested for precise values such as `gender == "men"` or `size == "xs"` and the values are internal to your system (that is, not free form user-submitted data etc.) an enumeration might be a good choice.

An enumeration in GraphQL is like a Scaler type in that it is a leaf in the data graph, a datum that cannot be drilled down further.

Here are some examples (note that uppercase here is pure style, void of semantics):

```
enum Size = {
  S
  M
  L
}
```
```
enum Gender = {
  MALE
  FEMALE
}
```
```
enum OrderStatus = {
  INVOICED
  PICKED
  PACKED
  SHIPPED
  DELIVERED
  RETURNED
}
```


### Object

Object types provide the means to create a set of field names and their corresponding types that logically represent something concrete in the author's domain like a product, article, comment, or user. Unsurprisingly they tend to be the workhorse of an author's schema.

```
type Product = {
  id: ID
  name: String
  price: Float
  countryOfManufacture: Country
  brand: Brand
  colour: Colour
  gender: Gender
}
```

### List

List types allow expressing the possibility of none, one, or many of some type.

```
type SearchResult = {
  products: [Product]
}
```

### The special Object Type named Query

Every queryable schema will have at least one Object type specially named `Query`. Given this name, a special thing happens to the fields of this object: they become the top-level fields of this GraphQL server, also known as its entry-point or root. So with this in place it becomes possible for clients to begin a query against the data presented by GraphQL server starting with any one of the fields exposed in the Query Object type.

For example given this Query type:

```
type Query {
  users: [User]
  products: [Product]
  articles: [Article]
  jobPostings: [JobPosting]
}
```

A client may query any of the fields above:

```
query {
  users: {
    id
    name
    email
  }
}
```

```
query {
  products: {
    id
    price
    countryOfManufacture
  }
}
```

And so on.

### Queries

We have just seen some queries. Here are a few more. But note that these are all somewhat arbitrary given we're working with a subset of query features that omit some things many real-world queries would include.

Get all brands, products of each brand, and all users who have purchased from each brand:

```
query {
  brands: {
    id
    name
    products: {
      id
      name
      price
    }
    purchasers: {
      id
      name
    }
  }
```

Find out for each country various stats about our platform including users who have purchases from brands in that country and users who simply live in that country.

```
query {
  countries {
    brandsBasedIn: {
      id
      name
      cityBasedIn
      purchasers: {
        id
        name
      }
    }
    productsShippedTo: {
      id
      price
    }
    productsManufacturedIn: {
      id
      name
      brand: {
        id
        name
      }
    }
    usersInhabiting: {
      id
      name
    }
  }
}
```

Some things you might notice:

. Fields are explicitly listed. This is known as the _selection set_. Any field not in the selection set will not be part of the result. Therefore the shape of data being returned is self-evident in the query itself. This is vastly different than how most RESTful APIs work wherein endpoints have predetermined response data and finding out what that data is requires looking at documentation or executing a query.

. Queries may run against a graph of data. This is not a requirement but for data that has inherit relationships it is the generally recommended way to design your GraphQL schema and hence why the word graph shows up in its name. That said its certainly possible to design a GraphQL schema that is not graph like at all.

. Data is returned as a tree. If the data being queried is indeed a graph then the result can be seen as a sub-graph.

. List and Object types are queried with the exact same syntax. Clients will generally rely on the type system and on well named fields to reason about which fields are lists and which are objects. This may take some getting used to for beginners.

. The results of either query will contain many of the same products multiple times due to the graph nature of the query. Backend implementations have various techniques to prevent double-fetching data in the process of resolving a query.

#### Tradeoffs of Field-level granularity

As mentioned the field-level granularity of GraphQL is a huge departure from traditional REST APIs, and is worth considering a bit more before we move on.

Compared to REST the verbosity of constructing a query in code will increase with GraphQL since every piece of data the client needs must be explicitly stated.

But the payback for this seems to make this a great tradeoff.

* Frontend engineers can literally see the shape of data they will receive.

* It is now possible in a fairly general way for tools to generate application-level types by combining queries in the app with the GraphQL server's schema definition.

* It is now possible in a fairly general way for tools to validate queries at dev time by sending them to the GraphQL server for validation as you write them.

* Frontend engineers can copy-paste into tools like https://github.com/graphql/graphiql[GraphiQL] to interactively explore data, then copy-paste back into their code.

* Backend teams can now know precisely how much each field is used by clients. This can inform their decisions about which fields to optimize performance on or how to evolve a schema.

* Backend teams are free to evolve the schema without having to worry that additions will bloat response payloads to client queries unbeknownst to the Frontend engineers responsible for application stability and performance.

* Traditional caching techniques are not going to be as effective as in REST since there may be many permutations of client queries. The loss in traditional cache effectiveness will vary case by case particularly based on how many unique queries are reaching the GraphQL server. For instance a public GraphQL API might find little use for traditional cache systems whereas a private one for only one or two first party apps might fare quite fine. My take is that:

. GraphQL exists in an age where the expectation on average backend system performance is higher given an industry with access to high performance languages (e.g. Go, Elixir, Node, ...)  and elastic infrastructure (Docker, Kubernetes, Cloud)

. GraphQL exists in an age where real-time is becoming standard, which has an inherent tension with cache.

. Rather than having a fat cache layer at the top, strategical application-level caches (in-app or sidecar proxy deployments) are an alternative that especially make more sense in a world of micro-services and correspondingly micro-teams around them.

. If the GraphQL server is fronting graph-like data then that means a single query can traverse potentially deeply into the graph. In such a case a single cache policy like one might expect of RESTful endpoints doesn't make sense for GraphQL since all the data is accessible from a single endpoint. Instead it seems that GraphQL would be better suited to field-level caching. Notably this has happened via https://www.apollographql.com/engine/[Apollo engine] which is a proxy providing cache features for Graphql called.






## Intermediate Types and Queries

### Non-Null

Non-Null types allow expressing that a field will never be `null`. If you are familiar with Maybe types (sometimes called Option type) from Haskell Scala Rust Swift Elm and others then you can view this type as a kind of reversal. In most programming languages the possibility of `null` is opted in by the user, but in GraphQL every field is maybe null by default, forcing schema authors to opt-out when they don't want this type. So somewhat paradoxically `Non-Null` "types" are really a means of simplifying and stripping away type information from fields!

Consider the following schema example:

```
query {
  products: [Product]
}
```

Ignoring the type of Product, statically typing the query result would look something like this, for example:

In Flowtype:

```typescript
type QueryResultProducts = null | Array<null | Product>
```

In Haskell:

```haskell
type QueryResultProducts = Maybe [Maybe Product]
```

But if the GraphQL schema author now uses some `Non-Null` types for their schema:

```
query {
  products: [Product!]!
}
```

Look what happens to the static types of the query result:

In Flowtype:

```typescript
type QueryResultProducts = Array<Product>
```

In Haskell:

```haskell
type QueryResultProducts = [Product]
```

Hopefully you can see now how `Non-Null` types in GraphQL are really a way to remove type information, not add it.

When `null` is impossible client code is simplified becuase they have fewer edge cases to account for. But care should be taken by schema authors to not over-promise when designing their schema too. Firstly, changing a field type from not-nullable to nullable is a breaking change while the reverse is not. Secondly, null propagates up the tree of fields to the first nullable field. So if null occurs when it was guaranteed not to the data dropped on the result will likely be worse than had null been a more granular possibility. For example instead of a single item in a list having an image link field be null the entire list of items might become null instead.

Both of these points are discussed in finer detail with examples by Caleb Meredith in https://medium.com/@calebmer/when-to-use-graphql-non-null-fields-4059337f6fc8[When to use GraphQL Non-Null Fields].


### Input Object

Most types in GraphQL are output based
TODO



## Advanced Types and Queries
### Interface

Interface types allow expressing a set of fields that other Object types must have.

```
interface Product {
  id: ID
  name: String
  price: Float
  countryOfManufacture: Country
  brand: Brand
  colour: Colour
  gender: Gender
}

type Bag implements Product {
}

type Shoe implements Product {
}
```

This has multiple benefits. For schema authors working at scale Interfaces are a design tool helping them reason about data relationships and enforcing those relationships at the server level. For clients, interfaces allow queries on unions to be simplified in some cases.

### Union

Union types allow expressing that a field may be one of several different Object types.

Example:
```
type Product {
  id: ID
  name: String
  price: Float
}

type Article {
  id: ID,
  title: String
  author: String
}

union SearchResult = Product | Article
```

You may be wondering how one queries on such a type:

```
search(term:String) {
  searchResult: {
    # ... fields for Product or Article ...???
  }
}
```

We will answer this once we dive into queries.

You may also be wondering how this relates to Sum Types (AKA Tagged Union Types, variant Record, Discriminated Union, Disjoint Union). My take is that while GraphQL Union types have some similarities to Sum Types they are less flexible given that they are constrained to being a union of just Object types. By comparison, Sum Types in the type systems of Haskell Rust Swift and many other programming languages are effectively a superset of enums:

1. Analog to GraphQL `Enumeration`:
+
```haskell
type Size = S | M | L
```
+
```haskell
type Gender = Male | Female
```

2. Analog to GraphQL `Union`:
+
```haskell
type SearchResult = Product String String Float | Article String String String
```

Alas in GraphQL we must cope with less general/flexible types, but thankfully taken together can still model our data with expressivity at least approaching Sum Types. I haven't yet taken the time to confirm with the community if this is true but I suspect that GraphQL's design decisions here were related to other design considerations on the query side, when actually fetching data against these types. As we will see queries against enum types versus union types are quite different.

If you do not have extensive experience modelling your data with Sum or Sum-like types you may find this article by Chad Austin useful: https://chadaustin.me/2015/07/sum-types/[Sum Types Are Coming: What You Should Know].



## More about Interfaces and Unions

* unions are good for modelling a field which may be of totally different types. For example an error or a value
* interfaces are good for modelling a field which may be one of several related values, for example maybe socks shoes coats gloves glasses and so on all share a base interface type.
* a nice feature of interfaces for clients making queries is that field type qualifications via e.g. inline fragments are not needed for interface-level fields. Only once the user wants fields particular to some type implementing the interface will they then need to break out into slightly more verbose query syntax.
* Conversely a field which is a union type can only be queried upon with inline fragments which first qualify the type.
* the effect on a query's verbosity probably shouldn't be the main concern however. Instead the domain itself should inform what the relationship of the data is and that in turn should inform how to model the data. For example I have seen one use-case for unions be putting errors inline with data such that a field can either be the data you requested or some error like authorization failure. Reference: TODO

## Anatomy of GraphQL Queries

Hopefully you now have a sense of what GraphQL is. Lets survey some of its main features so that you have a deeper understanding of what it can and cannot do in more precise operational terms.

### Document
### Selection Set
### Operation (query, mutation, subscription)
### Aliases
### Functions
### Opt-in
### Directives
### Fragments
### Variables



## Case Study

TODO

### Making a query

```
fragment RelatedProduct on Product {
  id,
  name,
  price: {
    amount(formatted: true)
  },
  primary_image(height: 50): {
    width,
    height,
    alt_text
  }
}
```
```
fragment AllMeasurements on ProductMeasurements {
  ... on Shirt {
    shoulders,
    chest,
    length,
    sleeve,
  }
}
```
```
query product(id: $product_id, language: $language, region: $region) {
  sku,
  name,
  summary,
  description,
  material_facts,
  in_my_wishlist,
  model: {
    description,
    size: {
      chest,
      hip,
      shoulder,
      waist,
    }
  },
  price {
    amount
    amount_formatted: amount(formatted: true),
    currency_name
  },
  styled_with: {
    ...RelatedProduct
  },
  images(width: 400): {
    width,
    height,
    alt_text
  },
  sizes: {
    id,
    name
    measurements: {
      ...AllMeasurements
    },
    stock,
  },
  category: {
    product_sizing_diagram,
    id,
    name
    products (limit: 7): {
      ...RelatedProduct
    }
  },
  brand: {
    id,
    name
    products(limit: 5, like_product: $product_id): {
      ...RelatedProduct
    }
  }
}
```

## Ecosystem

* queries are typed out literally in code, as-you-type validation
* GraphiQL, Voyager, Graphcool, Graphene, Relay, Apollo Client, Apollo Engine
* Authorization goes into the Authorization header
* user context aka `viewer` pattern
* Localization goes into Accept-Language header
* backend teams know how their servers are being used
* frontend teams only pay for what they use, example at SSENSE with price field

### Schema Driven Development

Interestingly schema definitions like the examples we saw while introducing the type system or presenting the case study can be transformed into a functioning GraphQL server by https://github.com/apollographql/graphql-tools[Apollo GraphQL Tools]. This is a declarative way of creating a GraphQL service because you simply say what the interface is and it becomes so. Apollo has termed this approach https://www.apollographql.com/docs/graphql-tools/index.html#recommendations[the GraphQL-first philosophy].

## Novelty

* Some of the things that make GraphQL notable are:

** its conservative iterative and organic development over years of production experience
** originated as a data solution for mobile apps, still driven by needs of frontend engineers
** particularly strong ecosystem support for React
** its rich type system including union types and opt-in null-free
** its opt-in field-level granularity query model
** its fields-are-functions query model
** its ecosystem of tooling
** its fundamental flexibility, such as not even requiring HTTP
** its interface unification of streaming and request-response

Some other technologies have overlapping benefits like https://grpc.io[gRPC]  (strong types, unified streaming/request-response interface) or http://netflix.github.io/falcor/[Falcor] (graph queries, data layer abstraction), but GraphQL is ultimately highly unique in its intersection of characteristics.

## An Ecosystem

TODO

## Summary

* GraphQL is a **specification** with _many implementations_
* GraphQL was originally created at Facebook but is now developed in the open by many companies and engineers.
* https://www.apollodata.com/[Apollo] is the/one of the most directly involved/invested companies in furthering the technology (not consumer but driver) outside of Facebook. Apollo is part of https://www.meteor.com[Meteor].

## References

* http://graphql.org/learn[official docs]
* http://facebook.github.io/graphql[spec]
* https://www.howtographql.com/
* https://github.com/chentsulin/awesome-graphql[awesome-graphql]
* https://twitter.com/tomdale/status/786951612053020672?lang=en
- https://github.com/sogko/graphql-schema-language-cheat-sheet[cheatsheet]

* https://stackoverflow.com/questions/34726666/real-world-example-of-graphqlinterfacetype-and-graphqluniontype
* https://github.com/graphql/graphql-js/issues/207
