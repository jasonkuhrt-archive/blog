:toc: macro
:toc-title:

# React Popover Layout System

This is a technical document regarding the design and layout techniques used in react-popover. If you are generally curious about what react-popover is, why it exists, etc. then you may want to read a link:/1-react-popover-history/README.adoc[recent article detailing its back-story].

toc::[]



## Anatomy

### Components

Our system is built around a set distinct components. All it knows about them is their position and dimensions (except Tip, we need to control its pointing direction too).

image::anatomy-components.png[]

##### Target

The aim of Popover.

##### Frame

Frame is the bounding box that Popover should remain within.

##### Popover

The thing we are positioning in relation to these. Our system will automatically position this component in the most optimal way possible.

##### Tip

A visual cue reflecting Popover's aim and is positioned relative to Popover and Target. Its importance to the system is less than other components since its removal would not significantly change it.



### Layout


The layout system's goal is to find the optimal position for Popover. In minor ways it has been inspired by Flexbox but is generally very much its own idea.

image::anatomy-layout.png[]

#### Main/Cross Axes

The relative axes of the system. Their concrete orientation depends upon Popover position relative to Target. The main axis along the orientation containing Popover adjacent to Target. The cross axis is parallel to the overall layout of Popover and Target.

#### Before/After Sides

If we abstract away concrete orientation then how do we continue thinking about the four sides of a box: top, right, bottom, left? The solution is to to remove their implied orientation and think about order. By prefixing the names of relative axes to disambiguate we are freed to generalize the four sides into two: before/after. The former refers to either top or left while the latter botttom or right footnote:[The choice of mapping "before" to "top" as opposed to "bottom" reflects the coordinate system on the web where 0,0 is top-left. To people familiar with Math, Adobe Flash, or other environments, this is unnatural but alas I took the expedient approach by staying consistent with the web.].

## Algorithm

### The optimal zone

image::zones.png[]

Popover will be positioned in the zone deemed best amongst all four possibilities. The algorithm executes in two phases. First measure the fit of each zone and then rank those fits to find the optimal zone.

##### Phase 1: Measure

For each zone we subtract Popover's height and width from it. When doing this we also have to factor in the Tip's main-axis length (see appendix A for how/why). The result is knowing how much spare space each zone would have on either of its dimensions after fitting Popover.

##### Phase 2: Rank

We group zones into first or second class. First class zones are those whose fit is positive on both dimensions. Second class zones are those whose fit is negative on one or both dimensions.

Next, pick the first class zone with the largest area. If there are no first class zones then pick the second class zone with least percentage area exceeding Frame bounds. This is your optimal zone.

Finally, check if the optimal zone just calculated beats previous optimal zone by the given threshold (see appendix B for how/why we support this). If it does then update Popover's position, otherwise do nothing.

##### Example layout scenarios

image::zone-scenarios2.png[]


### The Popover's position


With the optimal zone found we can now calculate the best position for Popover within it. Our algorithm looks for the position of Popover that would see its main axis matched to that of Target.

image::positioning-mca.png[]

Popover should generally stay fully within the Frame but when this is not possible a fallback strategy can be applied. There are several different ones we have thought of which the user could choose between depending upon his/her needs.

##### Bounded Mode

Popover may position up to the Frame boundary but not beyond it.

image::positioning-bounded.png[]

##### Unbounded Mode

Popover effectively ignores the Frame

image::positioning-unbounded.png[]

##### Semi-Bounded Mode

Popover is in bounded mode until some percentage of the Target's area exceeds Frame bounds at which point Popover is Unbounded.

image::positioning-semi-bounded.png[]

##### Future Work

Ideally we can allow the user to design their own bespoke strategy with ease. For example if there were an observable event stream regarding Target's area exceeding Frame bounds then users could execute arbitrary actions at any thresholds, e.g. instead of making Popover enter unbounded mode just close it.

There are also other conceivable factors that could be the basis for more modes including a threshold of Popover's percentage area exceeding bounds (as opposed to the Target).



### The Tip's position

Our system assumes that Tip has a pointer on top and base on bottom. In other words that at rest (no rotation) Tip is pointing upward. Its layout rules are:

. Along main-axis: between Popover and Target
. Along cross-axis: centered between nearest before-side and after-side amongst Target and Popover
. Faces Target

The first rule is straight forward but the second deserves a visualization:

image::tip-centering.png[]

Faces target means that we must rotate Tip depending on which side of Target it finds itself:

image::tip-rotation.png[]



## Appendices

These appendices cover deep details that underpin reliable layout.

### Appendix A: Infinite Loop

When calculating a zone's fit the Tip's contribution to Popover dimensions must be specially handled. If it were not then an infinite loop of zone rank changes could occur in cases involving only second-class options.

##### Problem

Observe that that Tip length affects either height or width of Popover depending upon the zone side. As such zones of opposite orientation manifest slightly different Popover dimensions. If not handled right this can trigger an infinite layout loop between two second-class zones of opposite orientation. Said change in dimension will affect the percentage of crop experienced by Popover in turn leading to always another zone appearing superior than the current one. The following diagram helps illustrate this.

##### Example scenario were we not to account for Tip

image::infini-loop.png[]

1. Popover in place from some previous lead up or just positioned and then dimensions change because of Tip movement
2. A new optimal zone in first class is detected
3. Popover positioned. Dimensions change because of Tip movement
4. A new optimal zone in first class is detected
5. Go to 1...



##### Solution

A non-general solution to this problem is to always add the Tip's main-axis length to Popover's main-axis length when calculating a zone's fit rank. For example for top zone add Tip length to the Popover height; for right zone add Tip length to Popover width; etc.

TODO diagram

If we revisit the scenario from before it would now play out more like the following.

##### Example Scenario when we do account for Tip

image::infini-loop-fixed.png[]

1. Popover in place from some previous lead up
2. Some change triggers a layout scan, another zone is closely ranked but given that its in the same class and exceeds Frame bounds more than in current position, current position remains.
3. Done!

### Appendix B: Minimum-improvement Thresholds to prevent layout Jitter

Thresholds are needed to prevent layout jitter (bad for user-experience) caused by zones with tight ranking flipping around the precipice. The diagrams show examples of how minor jitters can be magnified into excessive layout changes.

The underlying problem thresholds solve is that without them we have tightly coupled jitter from the inputs (arrangement, size, etc. of Target, Popover, Frame) to pass right through to our output (zone ranking). Thresholds allow us to define and filter out insignificant zones rank changes, controlling the balance between optimal positioning and layout stability.

Some threshold examples:

* threshold 0.2 means balance stability and positioning: other zones need 20% greater area for change
* threshold 0 means prioritize optimal position: other zones need 1px greater area for change

image::change-threshold-0.png[]

* threshold Infinity means prioritize stability: other zones are never changed to unless it would mean upgrading from second class to first

It may be useful to let users decide if they want to opt-in/out of zone class upgrades thereby limiting criteria for zone changes strictly to their differences in area.
