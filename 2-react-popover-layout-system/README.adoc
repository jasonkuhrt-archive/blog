:toc: macro
:toc-title:

# React Popover Layout Algorithm

This is a technical document regarding the design and layout techniques used in react-popover. If you are generally curious about what react-popover is, why it exists, etc. then you may want to read a recent article detailing its back-story.

toc::[]

## Component Anatomy

Our system is built around few components with distinct roles. All it knows about them is their position and dimensions (except Tip, we need to control its pointing direction too).

image::anatomy-components.png[]

##### Target

The aim of Popover.

##### Frame

Frame is the bounding box that Popover should remain within.

##### Popover

The thing we are positioning in relation to these. Our system will automatically position this component in the most optimal way possible.

##### Tip

A visual cue reflecting Popover's aim and is positioned relative to Popover and Target. Its importance to the system is less than other components since its removal would not significantly change it.




## Layout Anatomy


The layout system's goal is to find the optimal position for Popover. In minor ways it has been inspired by Flexbox but is generally very much its own idea.

#### Relative Axes

In our system relative axes are "main axis" and "cross axis" whose concrete orientation depends upon Popover position relative to Target. The main axis is whichever one whose orientation contains Popover adjacent to Target. For example if Popover is horizontally adjacent to Target then the main axis is horizontal. The cross axis is simply whatever orientation main axis is not.

#### Ordinal Sides

If we abstract away concrete orientation then how do we continue thinking about the four sides of a box: top, right, bottom, left? The solution is to to remove their implied orientation and think about order. By prefixing the names of relative axes to disambiguate we are freed to generalize the four sides into two: before/after. The former refers to either top or left while the latter botttom or right footnote:[The choice of mapping "before" to "top" as opposed to "bottom" reflects the coordinate system on the web where 0,0 is top-left. To people familiar with Math, Adobe Flash, or other environments, this is unnatural but alas I took the expedient approach by staying consistent with the web.].

#### Diagram

image::anatomy-layout.png[]

## Calculate the optimal zone

image::zones.png[]

Popover will be positioned in the zone deemed best amongst all four possibilities. The algorithm requires two passes. First calculate the fit of each zone and then rank those fits to find the optimal zone.

#### Phase 1: Measure

For each zone we subtract Popover's height and width from it. When doing this we also have to factor in the Tip's main-axis length (see appendix A for how/why). The result is knowing how much spare space each zone would have on either of its dimensions after fitting Popover.

#### Phase 2: Rank

We group zones into first or second class. First class zones are those whose fit is positive on both dimensions. Second class zones are those whose fit is negative on one or both dimensions.

Next, pick the first class zone with the largest area. If there are no first class zones then pick the second class zone with least percentage area exceeding Frame bounds. This is your optimal zone.

Finally, check if the optimal zone just calculated beats previous optimal zone by the given threshold (see appendix B for how/why we support this). If it does then update Popover's position, otherwise do nothing.

#### Example layout scenarios

image::zone-scenarios2.png[]



## Calculate Popover position


With the optimal zone found we can now calculate the best position for Popover within it. Our algorithm looks for the position of Popover that would see its main axis matched to that of Target.

image::positioning-mca.png[]

Depending on what the user has decided, this positioning may behave in three distinct ways: sensitive to Frame bounds, insensitive to frame bounds, sensitive to Frame bounds up to a given threshold. Respectively these modes are called "bounded", "unbounded", "semi-bounded".

If positioning Popover to have its main axis exactly match Target's would cause Popover to exceed Frame bounds, then...

* **Bounded**
...position Popover up to Frame edge but not beyond it

image::positioning-bounded.png[]

* **Unbounded**
...go ahead

image::positioning-unbounded.png[]

* **Semi-Bounded**
...calculate if the area percentage cropped of Target would exceed given threshold. If yes, then be unbounded, else be bounded.
+
It is conceivable that another factor for the threshold could be the _Popover's_ percentage area cropped. Its unclear to me if this would be useful or not though.
+
image::positioning-semi-bounded.png[]



## Calculate Tip position

As mentioned in the introductory anatomy Tip is a sub-component of Popover, its job to visually hint Popover's reference of Target. Our system assumes that Tip has a pointer on top and base on bottom. In other words that at rest (no rotation) Tip is pointing upward. Its layout rules are:

* Along main-axis: between Popover and Target
* Along cross-axis: centered between nearest before-side and after-side amongst Target and Popover
* Faces Target

image::tip-centering.png[]
image::tip-rotation.png[]



## Appendices

These appendices cover deep details that underpin reliable layout.

### Appendix A: Infinite Loop

When calculating a zone's fit the Tip's contribution to Popover dimensions must be specially handled. If it were not then an infinite loop of zone rank changes could occur in cases involving only second-class options.

Tip length affects either height or width of Popover depending upon the zone side. So two zones of opposite orientation are going to manifest slightly different Popover dimensions. Consequently this could affect Popover crop percentage in second-class zones leading to always another zone appearing better than the current one. The diagram helps illustrate such a case.

A non-general solution to this problem is to always add the Tip's main-axis length to Popover's main-axis length when calculating a zone's fit rank. For example for top zone add Tip length to the Popover height; for right zone add Tip length to Popover width; etc.

#### Example Scenario

image::infini-loop.png[]


1. Popover moved and dimensions change because of Tip movement
2. A new optimal zone (Tier 1) is calculated
3. Popover moved and dimensions change because of Tip movement
4. A new optimal zone (Tier 1) is calculated
5. Go to 1

### Appendix B: Minimum-improvement Thresholds to prevent layout Jitter

Thresholds are needed to prevent layout jitter (bad for user-experience) caused by zones with tight ranking flipping around the precipice. The diagrams show examples of how minor jitters can be magnified into excessive layout changes.

The underlying problem thresholds solve is that without them we have tightly coupled jitter from the inputs (arrangement, size, etc. of Target, Popover, Frame) to pass right through to our output (zone ranking). Thresholds allow us to define and filter out insignificant zones rank changes, controlling the balance between optimal positioning and layout stability.

Some threshold examples:

* threshold 0.2 means balance stability and positioning: other zones need 20% greater area for change
* threshold 0 means prioritize optimal position: other zones need 1px greater area for change

image::change-threshold-0.png[]

* threshold Infinity means prioritize stability: other zones are never changed to unless it would mean upgrading from second class to first

It may be useful to let users decide if they want to opt-in/out of zone class upgrades thereby limiting criteria for zone changes strictly to their differences in area.
